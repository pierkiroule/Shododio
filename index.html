<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>La Voix du SHODO — Pinceau Organique</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;1,300&family=Inter:wght@200;400&display=swap');

    :root {
      --bg: #f4f1ea;
      --ink: #0d0d0d;
      --vermilion: #c9301e;
      --indigo: #253a4f;
      --ui-bg: rgba(255,255,255,0.9);
    }

    body {
      margin: 0;
      overflow: hidden;
      background: var(--bg);
      font-family: 'Inter', sans-serif;
      touch-action: none;
      user-select: none;
      position: fixed;
      width: 100%;
      height: 100%;
      -webkit-tap-highlight-color: transparent;
    }

    canvas {
      position: absolute;
      inset: 0;
      display: block;
    }

    #paper-layer { z-index: 5; }

    .paper-texture {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 20;
      opacity: 0.18;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      mix-blend-mode: multiply;
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 20px;
      z-index: 100;
      transition: opacity 0.4s ease;
    }

    .top-ui {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    #status-msg {
      font-size: 0.65rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--indigo);
      text-shadow: 0 1px 0 rgba(255,255,255,0.8);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #rec-dot {
      width: 8px;
      height: 8px;
      background: var(--vermilion);
      border-radius: 50%;
      display: none;
    }
    #rec-dot.active { display: block; animation: pulse 1s infinite; }

    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }

    #timer-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      opacity: 0;
      transition: opacity 0.5s;
    }

    #timer-display {
      font-family: 'Cormorant Garamond', serif;
      font-size: 2.5rem;
      color: var(--ink);
      line-height: 1;
    }

    #timer-bar-bg {
      width: 100px;
      height: 2px;
      background: rgba(0,0,0,0.1);
      margin-top: 5px;
      position: relative;
    }

    #timer-bar {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--indigo), var(--ink), var(--vermilion));
      transform-origin: left;
      transform: scaleX(0);
    }

    #spectrum-viz {
      display: flex;
      gap: 4px;
      height: 4px;
      width: 60px;
      margin-top: 5px;
      opacity: 0;
      transition: opacity 0.5s;
    }
    .spec-bar { flex: 1; transform-origin: bottom; transform: scaleY(0); transition: transform 0.1s; }
    #spec-low { background: var(--indigo); }
    #spec-mid { background: var(--ink); }
    #spec-high { background: var(--vermilion); }


    .action-area {
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .controls-panel {
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
      padding: 12px 16px;
      border: 1px solid rgba(0,0,0,0.08);
      background: rgba(255,255,255,0.75);
      backdrop-filter: blur(6px);
      border-radius: 12px;
    }

    .floating-panel {
      position: fixed;
      right: 20px;
      bottom: 90px;
      width: 220px;
      z-index: 120;
      box-shadow: 0 14px 30px rgba(0,0,0,0.08);
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      cursor: grab;
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(13,13,13,0.6);
    }

    .panel-toggle {
      border: 1px solid rgba(0,0,0,0.2);
      background: transparent;
      color: var(--ink);
      font-size: 0.6rem;
      cursor: pointer;
      border-radius: 999px;
      padding: 4px 8px;
    }

    .panel-body {
      display: flex;
      flex-direction: column;
      gap: 14px;
      width: 100%;
    }

    .floating-panel.collapsed .panel-body {
      display: none;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }

    .control-label {
      font-size: 0.55rem;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      color: rgba(13,13,13,0.6);
    }

    .option-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }

    .size-row {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
      justify-content: center;
    }

    .size-row input[type="range"] {
      width: 140px;
      accent-color: var(--ink);
    }

    .size-value {
      font-size: 0.6rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(13,13,13,0.7);
      min-width: 48px;
      text-align: right;
    }

    .chip-btn {
      border: 1px solid rgba(0,0,0,0.18);
      background: rgba(255,255,255,0.9);
      color: var(--ink);
      font-size: 0.6rem;
      letter-spacing: 0.1em;
      padding: 6px 10px;
      text-transform: uppercase;
      cursor: pointer;
      border-radius: 999px;
      transition: all 0.2s ease;
    }

    .chip-btn.active {
      border-color: var(--ink);
      background: var(--ink);
      color: var(--bg);
    }

    .color-chip {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.2);
      cursor: pointer;
      position: relative;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .color-chip.active {
      transform: scale(1.1);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.4);
    }

    #preview-canvas {
      width: 180px;
      height: 110px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.15);
      background: rgba(255,255,255,0.7);
      box-shadow: inset 0 0 14px rgba(0,0,0,0.06);
      touch-action: none;
    }

    .main-btn {
      padding: 12px 28px;
      border: 1px solid var(--ink);
      background: var(--ink);
      color: var(--bg);
      letter-spacing: 0.15em;
      font-size: 0.7rem;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 180px;
    }

    .main-btn.secondary {
      background: transparent;
      color: var(--ink);
      border: 1px solid var(--ink);
    }

    .bottom-ui {
      display: flex;
      justify-content: center;
      gap: 20px;
      pointer-events: auto;
      margin-bottom: env(safe-area-inset-bottom);
    }

    .btn-circle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.1);
      background: var(--ui-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--ink);
      font-size: 1rem;
    }

    #boot-screen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.8s ease, visibility 0.8s;
      text-align: center;
      padding: 20px;
    }

    #boot-screen h1 {
      font-family: 'Cormorant Garamond';
      letter-spacing: 0.15em;
      font-weight: 300;
      font-size: 2rem;
      color: var(--ink);
      margin-bottom: 0.5rem;
    }

    #boot-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

    #init-btn {
      margin-top: 40px;
      padding: 16px 32px;
      background: transparent;
      border: 1px solid var(--ink);
      color: var(--ink);
      font-size: 0.75rem;
      letter-spacing: 0.25em;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
    }

    #replay-overlay {
      position: fixed;
      inset: 0;
      background: #080808;
      z-index: 200;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    #replay-overlay.active { display: flex; }

    video {
      max-width: 100%;
      max-height: 80vh;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
      border: 1px solid #333;
    }

    .replay-controls {
      margin-top: 20px;
      display: flex;
      gap: 20px;
    }

    .replay-btn {
      color: white;
      border: 1px solid white;
      padding: 10px 20px;
      background: transparent;
      cursor: pointer;
      text-transform: uppercase;
      font-size: 0.7rem;
      letter-spacing: 0.2em;
    }
    .replay-btn:hover { background: white; color: black; }
  </style>
</head>

<body>

  <div id="boot-screen">
    <h1>LA VOIX DU SHODO</h1>
    <p style="font-size: 0.7rem; letter-spacing: 0.15em; opacity: 0.6; margin-top: 0;">RITUEL SPECTRAL</p>
    <button id="init-btn">Activer le Pinceau</button>
  </div>

  <div id="replay-overlay">
    <video id="final-video" playsinline loop controls></video>
    <div class="replay-controls">
      <button id="dl-video-btn" class="replay-btn">Sauvegarder Vidéo</button>
      <button id="close-replay-btn" class="replay-btn">Fermer</button>
    </div>
  </div>

  <div class="paper-texture"></div>
  <canvas id="paper-layer"></canvas>

  <div id="ui-layer">
    <div class="top-ui">
      <div id="status-msg">
        <div id="rec-dot"></div>
        <span id="status-text">Prêt à tracer</span>
      </div>

      <div id="timer-container">
        <div id="timer-display">7.0</div>
        <div id="timer-bar-bg"><div id="timer-bar"></div></div>
        <div id="spectrum-viz">
          <div id="spec-low" class="spec-bar"></div>
          <div id="spec-mid" class="spec-bar"></div>
          <div id="spec-high" class="spec-bar"></div>
        </div>
      </div>
    </div>

    <div class="action-area">
      <button id="main-btn" class="main-btn">Lancer le cycle</button>
      <button id="secondary-btn" class="main-btn secondary" style="display:none;">Terminer l'oeuvre</button>
    </div>

    <div class="bottom-ui">
      <div id="reset-btn" class="btn-circle" title="Tout effacer">↺</div>
      <div id="save-btn" class="btn-circle" title="Image PNG">↓</div>
    </div>
  </div>

  <div id="floating-panel" class="controls-panel floating-panel">
    <div id="panel-header" class="panel-header">
      <span>Encre &amp; Pinceau</span>
      <button id="panel-toggle" class="panel-toggle" type="button">Masquer</button>
    </div>
    <div class="panel-body">
      <div class="control-group">
        <div class="control-label">Pinceaux</div>
        <div id="brush-options" class="option-row"></div>
      </div>
      <div class="control-group">
        <div class="control-label">Encres</div>
        <div id="color-options" class="option-row"></div>
      </div>
      <div class="control-group">
        <div class="control-label">Taille du tracé</div>
        <div class="size-row">
          <input id="size-range" type="range" min="0.6" max="1.6" step="0.05" value="1" />
          <span id="size-value" class="size-value">100%</span>
        </div>
      </div>
      <div class="control-group">
        <div class="control-label">Test Pinceau</div>
        <canvas id="preview-canvas" width="180" height="110"></canvas>
        <button id="preview-clear" class="chip-btn" type="button">Effacer</button>
      </div>
      <div class="control-group">
        <div class="control-label">Cycle</div>
        <div id="cycle-options" class="option-row"></div>
      </div>
    </div>
  </div>

  <script>
    const paper = document.getElementById("paper-layer");
    const ctxP = paper.getContext("2d", { alpha: false });

    let audioCtx, analyser, data, mediaStream;
    let phase = "READY";

    let startTime = 0;
    let timeLimit = 7000;
    let remainingTime = 0;

    let isDown = false;
    let lx, ly;
    let lastW = 0;
    let lastH = 0;
    let brushSizeScale = 1;
    let opacityScale = 1;

    const bands = { low: 0, mid: 0, high: 0 };
    const SILENCE_THRESHOLD = 0.01;
    const audioEnergy = { rms: 0, peak: 0 };
    let lastPeakTime = 0;

    let mediaRecorder;
    let recordedChunks = [];
    let isRecording = false;

    const brushes = [
      { id: "kasane", name: "Kasane", baseSize: 18, bristles: 18, spread: 1.1, flow: 0.7, jitter: 0.6, grain: 0.35 },
      { id: "kasure", name: "Kasure", baseSize: 12, bristles: 10, spread: 1.8, flow: 0.35, jitter: 0.4, grain: 0.75 },
      { id: "bokashi", name: "Bokashi", baseSize: 26, bristles: 8, spread: 1.3, flow: 0.25, jitter: 0.2, grain: 0.2 },
      { id: "hayai", name: "Hayai", baseSize: 10, bristles: 14, spread: 0.8, flow: 0.55, jitter: 0.9, grain: 0.45 },
      { id: "tsubu", name: "Tsubu", baseSize: 14, bristles: 6, spread: 2.1, flow: 0.4, jitter: 0.5, grain: 0.9 }
    ];

    const inkPalette = [
      { id: "sumi", name: "Sumi Noir", value: "#14110f" },
      { id: "sumi-warm", name: "Sumi Chaud", value: "#2a1d18" },
      { id: "ai", name: "Aï Indigo", value: "#2c3b52" },
      { id: "shu", name: "Shu Vermillon", value: "#b73a26" },
      { id: "kokutan", name: "Kokutan", value: "#1b1a16" },
      { id: "matsu", name: "Matsu", value: "#2c3a2f" }
    ];

    let activeBrush = brushes[0];
    let activeInk = inkPalette[0];
    let timeData;
    let cycleMode = "single";
    let cycleIndex = 0;
    const cycleDurations = [5000, 7000, 3000];
    let previewCtx;
    let previewCanvas;
    let previewDown = false;
    let previewLx;
    let previewLy;

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function hexToRgb(hex) {
      const clean = hex.replace("#", "");
      const intVal = parseInt(clean, 16);
      return {
        r: (intVal >> 16) & 255,
        g: (intVal >> 8) & 255,
        b: intVal & 255
      };
    }

    function mixColor(rgb, target, amount) {
      return {
        r: Math.round(rgb.r + (target.r - rgb.r) * amount),
        g: Math.round(rgb.g + (target.g - rgb.g) * amount),
        b: Math.round(rgb.b + (target.b - rgb.b) * amount)
      };
    }

    function rgba(rgb, alpha) {
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    }

    function initCanvasSize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      if (Math.abs(w - lastW) < 50 && Math.abs(h - lastH) < 100) return;
      lastW = w;
      lastH = h;
      paper.width = w;
      paper.height = h;
      clearAll();
    }

    function clearAll() {
      ctxP.fillStyle = "#f4f1ea";
      ctxP.fillRect(0, 0, paper.width, paper.height);

      for (let i = 0; i < 60000; i++) {
        const shade = Math.random();
        ctxP.fillStyle = `rgba(80,80,75,${shade * 0.08})`;
        ctxP.fillRect(Math.random() * paper.width, Math.random() * paper.height, 1, 1);
      }

    }

    function setupControls() {
      const brushContainer = document.getElementById("brush-options");
      const colorContainer = document.getElementById("color-options");
      const cycleContainer = document.getElementById("cycle-options");
      brushContainer.innerHTML = "";
      colorContainer.innerHTML = "";
      cycleContainer.innerHTML = "";

      brushes.forEach((brush, index) => {
        const btn = document.createElement("button");
        btn.className = "chip-btn";
        btn.textContent = brush.name;
        btn.dataset.brushId = brush.id;
        if (index === 0) btn.classList.add("active");
        btn.addEventListener("click", () => {
          activeBrush = brush;
          [...brushContainer.querySelectorAll(".chip-btn")].forEach(el => el.classList.remove("active"));
          btn.classList.add("active");
        });
        brushContainer.appendChild(btn);
      });

      inkPalette.forEach((ink, index) => {
        const chip = document.createElement("button");
        chip.className = "color-chip";
        chip.style.background = ink.value;
        chip.title = ink.name;
        chip.dataset.inkId = ink.id;
        if (index === 0) chip.classList.add("active");
        chip.addEventListener("click", () => {
          activeInk = ink;
          [...colorContainer.querySelectorAll(".color-chip")].forEach(el => el.classList.remove("active"));
          chip.classList.add("active");
        });
        colorContainer.appendChild(chip);
      });

      const cycles = [
        { id: "single", name: "7s" },
        { id: "haiku", name: "Haïku 5·7·3" }
      ];

      cycles.forEach((cycle, index) => {
        const btn = document.createElement("button");
        btn.className = "chip-btn";
        btn.textContent = cycle.name;
        btn.dataset.cycleId = cycle.id;
        if (index === 0) btn.classList.add("active");
        btn.addEventListener("click", () => {
          cycleMode = cycle.id;
          cycleIndex = 0;
          [...cycleContainer.querySelectorAll(".chip-btn")].forEach(el => el.classList.remove("active"));
          btn.classList.add("active");
          updateCycleStatus();
        });
        cycleContainer.appendChild(btn);
      });

      setupPanelInteractions();
      setupBrushSizeControls();
      setupPreviewCanvas();
    }

    function setupPanelInteractions() {
      const panel = document.getElementById("floating-panel");
      const header = document.getElementById("panel-header");
      const toggleBtn = document.getElementById("panel-toggle");
      let dragging = false;
      let offsetX = 0;
      let offsetY = 0;

      toggleBtn.addEventListener("click", () => {
        panel.classList.toggle("collapsed");
        toggleBtn.textContent = panel.classList.contains("collapsed") ? "Afficher" : "Masquer";
      });

      header.addEventListener("pointerdown", (event) => {
        if (event.target === toggleBtn) return;
        dragging = true;
        header.setPointerCapture(event.pointerId);
        const rect = panel.getBoundingClientRect();
        offsetX = event.clientX - rect.left;
        offsetY = event.clientY - rect.top;
        panel.style.right = "auto";
        panel.style.bottom = "auto";
        panel.style.left = `${rect.left}px`;
        panel.style.top = `${rect.top}px`;
        header.style.cursor = "grabbing";
      });

      header.addEventListener("pointermove", (event) => {
        if (!dragging) return;
        const x = clamp(event.clientX - offsetX, 12, window.innerWidth - panel.offsetWidth - 12);
        const y = clamp(event.clientY - offsetY, 12, window.innerHeight - panel.offsetHeight - 12);
        panel.style.left = `${x}px`;
        panel.style.top = `${y}px`;
      });

      header.addEventListener("pointerup", (event) => {
        dragging = false;
        header.releasePointerCapture(event.pointerId);
        header.style.cursor = "grab";
      });
    }

    function setupBrushSizeControls() {
      const sizeRange = document.getElementById("size-range");
      const sizeValue = document.getElementById("size-value");

      const updateSizing = (value) => {
        const numeric = parseFloat(value);
        brushSizeScale = numeric;
        opacityScale = clamp(1.4 - brushSizeScale * 0.5, 0.6, 1.2);
        sizeValue.textContent = `${Math.round(brushSizeScale * 100)}%`;
      };

      sizeRange.addEventListener("input", (event) => updateSizing(event.target.value));
      updateSizing(sizeRange.value);
    }

    function setupPreviewCanvas() {
      previewCanvas = document.getElementById("preview-canvas");
      previewCtx = previewCanvas.getContext("2d");
      clearPreview();

      previewCanvas.addEventListener("pointerdown", (event) => {
        previewDown = true;
        previewCanvas.setPointerCapture(event.pointerId);
        previewLx = event.offsetX;
        previewLy = event.offsetY;
      });

      previewCanvas.addEventListener("pointermove", (event) => {
        if (!previewDown) return;
        const x = event.offsetX;
        const y = event.offsetY;
        if (previewLx !== undefined) {
          drawSpectralBrush(previewCtx, previewLx, previewLy, x, y, 1, getPreviewDrive());
        }
        previewLx = x;
        previewLy = y;
      });

      previewCanvas.addEventListener("pointerup", (event) => {
        previewDown = false;
        previewCanvas.releasePointerCapture(event.pointerId);
        previewLx = undefined;
        previewLy = undefined;
      });

      document.getElementById("preview-clear").addEventListener("click", clearPreview);
    }

    function clearPreview() {
      if (!previewCtx) return;
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.fillStyle = "rgba(255,255,255,0.8)";
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
    }

    function getPreviewDrive() {
      const pulse = 0.5 + 0.5 * Math.sin(performance.now() / 450);
      return {
        bands: {
          low: clamp(0.25 + pulse * 0.25, 0, 1),
          mid: clamp(0.35 + pulse * 0.3, 0, 1),
          high: clamp(0.2 + pulse * 0.25, 0, 1)
        },
        energy: {
          rms: clamp(0.45 + pulse * 0.25, 0, 1),
          peak: clamp(0.2 + pulse * 0.35, 0, 1)
        },
        force: true
      };
    }

    function getCycleDuration() {
      if (cycleMode === "haiku") {
        return cycleDurations[cycleIndex] || cycleDurations[cycleDurations.length - 1];
      }
      return 7000;
    }

    function updateCycleStatus() {
      if (cycleMode === "haiku") {
        statusText.innerText = `Haïku — cycle ${cycleIndex + 1}/3`;
      } else {
        statusText.innerText = "Prêt à tracer";
      }
    }

    async function startAudio() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaStream = stream;

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.3;
        audioCtx.createMediaStreamSource(stream).connect(analyser);
        data = new Uint8Array(analyser.frequencyBinCount);
        timeData = new Uint8Array(analyser.fftSize);

        setupRecorder();

        document.getElementById("boot-screen").classList.add("hidden");
        loop();
        requestAnimationFrame(audioLoop);
      } catch (e) {
        console.error(e);
        alert("Micro requis.");
      }
    }

    function setupRecorder() {
      try {
        const canvasStream = paper.captureStream(30);
        const combinedStream = new MediaStream([
          ...canvasStream.getVideoTracks(),
          ...mediaStream.getAudioTracks()
        ]);

        const options = { mimeType: "video/webm;codecs=vp9" };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = "video/webm";
          if (!MediaRecorder.isTypeSupported(options.mimeType)) options.mimeType = "";
        }

        mediaRecorder = new MediaRecorder(combinedStream, options);

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) recordedChunks.push(event.data);
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: recordedChunks[0] ? recordedChunks[0].type : "video/webm" });
          const url = URL.createObjectURL(blob);
          document.getElementById("final-video").src = url;

          document.getElementById("dl-video-btn").onclick = () => {
            const a = document.createElement("a");
            a.style.display = "none";
            a.href = url;
            a.download = `lavoixdushodo_${Date.now()}.webm`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
          };
          showReplay();
        };
      } catch (e) {
        console.error("Erreur recorder", e);
      }
    }

    function audioLoop() {
      if (!analyser) return requestAnimationFrame(audioLoop);
      analyser.getByteFrequencyData(data);
      analyser.getByteTimeDomainData(timeData);

      const binCount = data.length;
      const lowLimit = Math.floor(binCount * 0.08);
      const midLimit = Math.floor(binCount * 0.45);

      let l = 0;
      let m = 0;
      let h = 0;

      for (let i = 0; i < binCount; i++) {
        const v = data[i] / 255;
        if (i < lowLimit) l += v;
        else if (i < midLimit) m += v;
        else h += v;
      }

      const rawL = (l / lowLimit) * 2.8;
      const rawM = (m / (midLimit - lowLimit)) * 3.2;
      const rawH = (h / (binCount - midLimit)) * 6.2;

      bands.low += (clamp(rawL, 0, 1) - bands.low) * 0.25;
      bands.mid += (clamp(rawM, 0, 1) - bands.mid) * 0.25;
      bands.high += (clamp(rawH, 0, 1) - bands.high) * 0.2;

      let sum = 0;
      for (let i = 0; i < timeData.length; i++) {
        const v = (timeData[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / timeData.length);
      const normalized = clamp((rms - 0.015) / 0.23, 0, 1);
      audioEnergy.rms += (normalized - audioEnergy.rms) * 0.3;

      const now = performance.now();
      if (normalized > 0.25 && now - lastPeakTime > 120) {
        audioEnergy.peak = 1;
        lastPeakTime = now;
      }
      audioEnergy.peak = Math.max(0, audioEnergy.peak - 0.12);

      if (phase === "DRAWING") {
        document.getElementById("spec-low").style.transform = `scaleY(${bands.low})`;
        document.getElementById("spec-mid").style.transform = `scaleY(${bands.mid})`;
        document.getElementById("spec-high").style.transform = `scaleY(${bands.high})`;
      }

      requestAnimationFrame(audioLoop);
    }

    function drawSpectralBrush(ctx, x1, y1, x2, y2, life, drive = { bands, energy: audioEnergy, force: false }) {
      const localBands = drive.bands || bands;
      const localEnergy = drive.energy || audioEnergy;
      const totalVol = localBands.low + localBands.mid + localBands.high + localEnergy.rms;
      if (!drive.force && totalVol < SILENCE_THRESHOLD) return;

      const dist = Math.hypot(x2 - x1, y2 - y1);
      const steps = Math.max(1, Math.floor(dist));

      const speed = clamp(dist / 10, 0, 1);
      const pressure = 1.0 - (speed * 0.6);
      const whisper = localEnergy.rms < 0.18;
      const brush = activeBrush;
      const baseRgb = hexToRgb(activeInk.value);
      const deepRgb = mixColor(baseRgb, { r: 0, g: 0, b: 0 }, 0.35);
      const mistRgb = mixColor(baseRgb, { r: 255, g: 255, b: 255 }, 0.5);

      ctx.save();
      ctx.globalCompositeOperation = "multiply";

      let dx = x2 - x1;
      let dy = y2 - y1;
      const len = Math.sqrt(dx * dx + dy * dy);
      let nx = 0;
      let ny = 0;
      if (len > 0) {
        nx = -dy / len;
        ny = dx / len;
      }

      const audioBoost = 1 + localEnergy.rms * 0.9 + localEnergy.peak * 1.1;
      const jitterBase = (localBands.high * 10 + localEnergy.rms * 10) * brush.jitter * audioBoost;

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        let cx = x1 + (x2 - x1) * t;
        let cy = y1 + (y2 - y1) * t;

        cx += (Math.random() - 0.5) * jitterBase;
        cy += (Math.random() - 0.5) * jitterBase;

        if (whisper) {
          const washSize = (brush.baseSize * brushSizeScale * 1.9 + localBands.low * 20) * pressure;
          ctx.fillStyle = rgba(mistRgb, 0.1 * brush.flow * opacityScale);
          ctx.beginPath();
          ctx.ellipse(cx, cy, washSize, washSize * 0.65, Math.random() * Math.PI, 0, Math.PI * 2);
          ctx.fill();
        }

        if (localBands.low > 0.03) {
          const offset = (Math.random() - 0.5) * 20 * localBands.low * brush.spread;
          const bx = cx + nx * offset;
          const by = cy + ny * offset;

          const size = (brush.baseSize * brushSizeScale * 0.6 + localBands.low * 26) * pressure * audioBoost;
          const alpha = 0.1 * localBands.low * brush.flow * (whisper ? 0.5 : 1) * opacityScale;

          ctx.fillStyle = rgba(deepRgb, alpha);
          ctx.beginPath();
          ctx.ellipse(bx, by, size, size * 0.55, Math.random() * Math.PI, 0, Math.PI * 2);
          ctx.fill();

          if (Math.random() < 0.08 * localBands.low) {
            const stainSize = size * (1.6 + localBands.low);
            addStain(ctx, bx, by, stainSize, baseRgb, localBands.low * 0.6);
          }
        }

        if (localBands.mid > 0.02) {
          const widthBoost = whisper ? 1.5 : 1;
          const brushWidth = (brush.baseSize * brushSizeScale * brush.spread + localBands.mid * 22) * pressure * widthBoost * audioBoost;
          const bristles = Math.max(6, Math.round(brush.bristles + localBands.mid * 12));

          for (let b = 0; b < bristles; b++) {
            const spread = (Math.random() - 0.5) * brushWidth * 2;

            if (speed > 0.6 && Math.random() > brush.flow) continue;

            const mx = cx + nx * spread;
            const my = cy + ny * spread;

            const size = (0.6 + Math.random()) * pressure * (whisper ? 0.8 : 1) * brushSizeScale;

            let alpha = 0.6 * localBands.mid * brush.flow;
            if (whisper) alpha *= 0.45;
            alpha *= opacityScale;

            if (Math.random() < brush.grain * 0.3) continue;

            ctx.fillStyle = rgba(baseRgb, alpha);
            ctx.beginPath();
            ctx.arc(mx, my, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        const splashIntensity = Math.max(localBands.high, localEnergy.peak);
        if (splashIntensity > 0.1) {
          if (Math.random() < 0.3 + splashIntensity * 0.6) {
            const scatter = (8 + splashIntensity * 40) * brush.spread;
            const hx = cx + (Math.random() - 0.5) * scatter;
            const hy = cy + (Math.random() - 0.5) * scatter;

            const size = (0.6 + Math.random() * (1 + splashIntensity)) * brushSizeScale;
            const alpha = 0.75 * splashIntensity * (whisper ? 0.5 : 1) * opacityScale;

            ctx.fillStyle = rgba(mixColor(baseRgb, { r: 255, g: 255, b: 255 }, 0.2), alpha);
            ctx.beginPath();
            ctx.arc(hx, hy, size, 0, Math.PI * 2);
            ctx.fill();
          }

          if (Math.random() < 0.12 * splashIntensity) {
            const len = 14 * splashIntensity;
            const ang = Math.random() * Math.PI * 2;
            ctx.strokeStyle = rgba(mistRgb, 0.5 * splashIntensity * opacityScale);
            ctx.lineWidth = 0.6;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + Math.cos(ang) * len, cy + Math.sin(ang) * len);
            ctx.stroke();
          }

          if (localEnergy.peak > 0.2 && Math.random() < 0.6) {
            addSplatter(ctx, cx, cy, localEnergy.peak, baseRgb);
            addStain(ctx, cx, cy, 22 + localEnergy.peak * 40, baseRgb, localEnergy.peak);
          }
        }
      }

      ctx.restore();
    }

    function addSplatter(ctx, cx, cy, intensity, baseRgb) {
      const drops = Math.ceil(8 * intensity);
      for (let i = 0; i < drops; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 10 + Math.random() * 30 * intensity;
        const sx = cx + Math.cos(angle) * radius;
        const sy = cy + Math.sin(angle) * radius;
        const size = (0.8 + Math.random() * 2.6 * intensity) * brushSizeScale;
        const alpha = 0.6 * intensity * opacityScale;
        ctx.fillStyle = rgba(mixColor(baseRgb, { r: 255, g: 255, b: 255 }, 0.15), alpha);
        ctx.beginPath();
        ctx.arc(sx, sy, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function addStain(ctx, cx, cy, size, baseRgb, intensity) {
      const radius = Math.max(12, size);
      const grad = ctx.createRadialGradient(cx, cy, radius * 0.1, cx, cy, radius);
      grad.addColorStop(0, rgba(baseRgb, 0.2 * intensity * opacityScale));
      grad.addColorStop(0.6, rgba(baseRgb, 0.08 * intensity * opacityScale));
      grad.addColorStop(1, rgba(baseRgb, 0));
      ctx.save();
      ctx.globalCompositeOperation = "multiply";
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(cx, cy, radius * 1.2, radius * 0.85, Math.random() * Math.PI, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function handleMove(e) {
      if (!isDown) return;
      const p = e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
      const x = p.x;
      const y = p.y;

      if (lx !== undefined && phase === "DRAWING") {
        const life = remainingTime / timeLimit;
        drawSpectralBrush(ctxP, lx, ly, x, y, life);
      }
      lx = x;
      ly = y;
    }

    function handleDown(e) {
      isDown = true;
      const p = e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
      lx = p.x;
      ly = p.y;
      handleMove(e);
    }

    function handleUp() {
      isDown = false;
      lx = undefined;
      ly = undefined;
    }

    document.body.addEventListener("pointerdown", handleDown);
    document.body.addEventListener("pointermove", handleMove);
    document.body.addEventListener("pointerup", handleUp);
    window.addEventListener("touchmove", e => e.preventDefault(), { passive: false });

    const mainBtn = document.getElementById("main-btn");
    const secBtn = document.getElementById("secondary-btn");
    const statusText = document.getElementById("status-text");
    const recDot = document.getElementById("rec-dot");
    const timerContainer = document.getElementById("timer-container");
    const specViz = document.getElementById("spectrum-viz");

    mainBtn.onclick = () => {
      if (phase === "READY" || phase === "PAUSED") {
        startCycle();
      }
    };

    secBtn.onclick = () => {
      if (phase === "PAUSED") {
        phase = "FINISHED";
        finishRitual();
      }
    };

    document.getElementById("reset-btn").onclick = resetRitual;
    document.getElementById("save-btn").onclick = () => {
      const a = document.createElement("a");
      a.download = `lavoixdushodo_${Date.now()}.png`;
      a.href = paper.toDataURL();
      a.click();
    };

    document.getElementById("init-btn").onclick = () => {
      if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
        DeviceMotionEvent.requestPermission().then(() => startAudio()).catch(() => startAudio());
      } else {
        startAudio();
      }
    };

    document.getElementById("close-replay-btn").onclick = () => {
      document.getElementById("replay-overlay").classList.remove("active");
      recordedChunks = [];
    };

    function startCycle() {
      phase = "DRAWING";
      timeLimit = getCycleDuration();
      startTime = Date.now();
      remainingTime = timeLimit;

      if (mediaRecorder && mediaRecorder.state === "inactive") {
        mediaRecorder.start();
        isRecording = true;
      } else if (mediaRecorder && mediaRecorder.state === "paused") {
        mediaRecorder.resume();
        isRecording = true;
      }

      recDot.classList.add("active");
      mainBtn.style.display = "none";
      secBtn.style.display = "none";
      timerContainer.style.opacity = 1;
      specViz.style.opacity = 1;
      if (cycleMode === "haiku") {
        statusText.innerText = `Encre haïku — cycle ${cycleIndex + 1}/3`;
      } else {
        statusText.innerText = "Enregistrement en cours...";
      }

      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
    }

    function pauseCycle() {
      phase = "PAUSED";

      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.pause();
        isRecording = false;
      }

      recDot.classList.remove("active");
      if (cycleMode === "haiku") {
        cycleIndex += 1;
        if (cycleIndex >= cycleDurations.length) {
          finishRitual();
          return;
        }
        mainBtn.innerText = "Cycle suivant";
        mainBtn.style.display = "block";
        secBtn.style.display = "none";
        statusText.innerText = `Respiration — prochain cycle ${cycleIndex + 1}/3`;
      } else {
        mainBtn.innerText = "Nouveau Cycle";
        mainBtn.style.display = "block";
        secBtn.style.display = "block";
        statusText.innerText = "Pause. Ajoutez ou terminez.";
      }
    }

    function finishRitual() {
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
      }

      timerContainer.style.opacity = 0;
      mainBtn.style.display = "none";
      secBtn.style.display = "none";
      statusText.innerText = "Rituel Terminé";
      recDot.classList.remove("active");
      cycleIndex = 0;
    }

    function showReplay() {
      document.getElementById("replay-overlay").classList.add("active");
      const v = document.getElementById("final-video");
      v.play();
    }

    function resetRitual() {
      phase = "READY";
      clearAll();
      recordedChunks = [];
      cycleIndex = 0;

      mainBtn.innerText = "Lancer le cycle";
      mainBtn.style.display = "block";
      secBtn.style.display = "none";

      timerContainer.style.opacity = 0;
      updateCycleStatus();
      recDot.classList.remove("active");
    }

    function loop() {
      if (phase === "DRAWING") {
        const elapsed = Date.now() - startTime;
        remainingTime = Math.max(0, timeLimit - elapsed);
        const ratio = remainingTime / timeLimit;

        document.getElementById("timer-display").innerText = (remainingTime / 1000).toFixed(1);
        document.getElementById("timer-bar").style.transform = `scaleX(${ratio})`;

        if (remainingTime <= 0) {
          pauseCycle();
        }
      }
      requestAnimationFrame(loop);
    }

    window.addEventListener("resize", initCanvasSize);
    setupControls();
    initCanvasSize();
  </script>
</body>
</html>
